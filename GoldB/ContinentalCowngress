import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;

public class ContinentalCowngress {
	
	static int numBills;
	static int numCows;
	static ArrayList<ArrayList<Integer>> visitable = new ArrayList<ArrayList<Integer>>();
	static boolean[] visited = new boolean[numBills];
	
	static ArrayList<ArrayList<Integer>> neighbors = new ArrayList<ArrayList<Integer>>();
	
	static boolean[] isPossible;
	
	static int[] possibility;
	
	final static int FALSE = -1;
	final static int MAYBE = 0;
	final static int TRUE = 1;
	
	static boolean impossible = false;
	
	public static void main(String[] args) throws IOException{
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer inputData = new StringTokenizer(reader.readLine());
		
		numBills = Integer.parseInt(inputData.nextToken());
		numCows = Integer.parseInt(inputData.nextToken());
		
		
		for(int i = 0; i < 2*numCows; i++){
			neighbors.add(new ArrayList<Integer>());
		}
		
		for(int i = 0; i < numCows; i++){
			inputData = new StringTokenizer(reader.readLine());
			int bill1 = Integer.parseInt(inputData.nextToken()) - 1;
			
			boolean bill1Result = inputData.nextToken().equals("Y") ? true : false;
			
			int bill2 = Integer.parseInt(inputData.nextToken()) - 1;
			
			boolean bill2Result = inputData.nextToken().equals("Y") ? true : false;
			
			neighbors.get(convertNodeNumber(bill1, !bill1Result)).add(convertNodeNumber(bill2, bill2Result));
			
			neighbors.get(convertNodeNumber(bill2, !bill2Result)).add(convertNodeNumber(bill1, bill1Result));
			
		}
		visited = new boolean[numBills*2];
		isPossible = new boolean[numBills*2];
		possibility = new int[numBills];
		
		for(int currentNode = 0; currentNode < numBills; currentNode++){
			Arrays.fill(isPossible, true);
			Arrays.fill(visited, false);
			visited[currentNode] = true;
			boolean isTrue = isTrue(currentNode);
			Arrays.fill(isPossible, true);
			Arrays.fill(visited, false);
			visited[currentNode] = true;
			boolean isFalse = isTrue(getOpposite(currentNode));
			if(isTrue){
				if(isFalse){
					possibility[currentNode] = MAYBE;
				}
				else{
					possibility[currentNode] = TRUE;
				}
			}
			else if (isFalse){
				possibility[currentNode] = FALSE;
			}
			else{
				impossible = true;
				break;
			}
		}
		
		if(impossible){
			System.out.println("IMPOSSIBLE");
		}
		else{
			for(int currentBill = 0; currentBill  < numBills; currentBill++){
				if(possibility[currentBill] == TRUE){
					System.out.print("Y");
				}
				else if(possibility[currentBill] == FALSE){
					System.out.print("N");
				}
				else{
					System.out.print("?");
				}
			}
			System.out.println();
		}
		
		
	}
	
	public static int convertNodeNumber(int billNumber, boolean result){
		return billNumber + (result ? 0 : numBills);
	}
	
	public static int getOpposite(int billNumber){
		if(billNumber - numBills >= 0){
			return billNumber - numBills;
		}
		else{
			return billNumber + numBills;
		}
	}
	
	public static boolean isTrue(int currentNode){
		if(!isPossible[currentNode]){
			return false;
		}
		
		isPossible[getOpposite(currentNode)] = false;
		
		for(int neighbor : neighbors.get(currentNode)){
			if(visited[neighbor] == false){
				visited[neighbor] = true;
				if(!isTrue(neighbor)){
					return false;
				}
			}
		}
		return true;
	}
	
	
}
