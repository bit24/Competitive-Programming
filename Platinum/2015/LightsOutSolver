import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class LightsOutSolver {

	public static void main(String[] args) throws IOException {
		new LightsOutSolver().execute();
	}

	int numP;

	int[] pX;
	int[] pY;

	static final int CW = -1;
	static final int CCW = -2;
	static final int EXIT = -3;

	static final int LEFT = 0;
	static final int RIGHT = 1;

	int[] elements;
	int numE;

	int[][] map;

	ArrayList<Integer>[] lExtension;
	ArrayList<Integer>[] rExtension;

	int[] baseCost;
	int[] preSum;

	int solution;

	// use:[representation][LEFT or Right]
	int[][] maxAdCost;

	void execute() throws IOException {

		BufferedReader reader = new BufferedReader(new FileReader("lightsout.in"));

		numP = Integer.parseInt(reader.readLine());
		pX = new int[numP];
		pY = new int[numP];

		for (int i = 0; i < numP; i++) {
			StringTokenizer inputData = new StringTokenizer(reader.readLine());
			pX[i] = Integer.parseInt(inputData.nextToken());
			pY[i] = Integer.parseInt(inputData.nextToken());
		}
		reader.close();
		numE = numP * 2;
		elements = new int[numE];
		// definition elements[i]:
		// if even: is clockwise
		// if odd: distance

		for (int currInd = 0; currInd < numP; currInd++) {
			int prevInd = wrapP(currInd - 1);
			int nextInd = wrapP(currInd + 1);

			if ((pX[currInd] - pX[prevInd]) * (pY[nextInd] - pY[currInd])
					- (pY[currInd] - pY[prevInd]) * (pX[nextInd] - pX[currInd]) < 0) {
				elements[2 * currInd] = CW;
			} else {
				elements[2 * currInd] = CCW;
			}
			elements[2 * currInd + 1] = Math.abs((pX[currInd] - pX[nextInd]) + (pY[currInd] - pY[nextInd]));
		}
		elements[0] = EXIT;

		computeBaseCost();
		computeMap();
		computeExtensions();
		maxAdCost = new int[numP * numP][2];

		computeCosts();

		for (int start = 1; start < numP; start++) {
			if(map[start][start] != numP*start + start){
				continue;
			}
			int cost = maxAdCost[map[start][start]][0] - baseCost[start];
			if (cost > solution) {
				solution = cost;
			}
		}

		PrintWriter printer = new PrintWriter(new BufferedWriter(new FileWriter("lightsout.out")));
		printer.println(solution);
		printer.close();
	}

	void computeCosts() {
		for (int length = numP; length >= 1; length--) {
			for (int left = 1; left + length - 1 < numP; left++) {
				int right = left + length - 1;
				// if the range overlaps 0 (or numP) the max additional cost is automatically 0

				int rangeRep = map[left][right];

				if (rangeRep != numP * left + right) {
					// only evaluate a range once
					continue;
				}

				int crossover = preSum[right] - preSum[left];

				for (int side = 0; side < 2; side++) {
					// min max decision
					int maxLeft = 0;
					for (int newRep : lExtension[rangeRep]) {
						int cost = maxAdCost[newRep][LEFT] + elements[wrapE(2 * left - 1)];
						if (cost > maxLeft) {
							maxLeft = cost;
						}
					}

					int maxRight = 0;
					for (int newRep : rExtension[rangeRep]) {
						int cost = maxAdCost[newRep][RIGHT] + elements[wrapE(2 * right + 1)];
						if (cost > maxRight) {
							maxRight = cost;
						}
					}

					if (side == LEFT) {
						maxRight += crossover;
					} else {
						maxLeft += crossover;
					}

					maxAdCost[rangeRep][side] = Math.min(maxLeft, maxRight);
				}
			}
		}
	}

	int wrapE(int input) {
		if (input >= numE) {
			return input - numE;
		}
		if (input < 0) {
			return input + numE;
		}
		return input;
	}

	int wrapP(int input) {
		if (input >= numP) {
			return input - numP;
		}
		if (input < 0) {
			return input + numP;
		}
		return input;
	}

	void computeBaseCost() {
		baseCost = new int[numP];
		preSum = new int[numP];
		for (int i = 1; i < numP; i++) {
			preSum[i] = baseCost[i] = baseCost[i - 1] + elements[i * 2 - 1];
		}

		baseCost[numP - 1] = Math.min(baseCost[numP - 1], elements[(numP - 1) * 2 + 1]);
		for (int i = numP - 2; i >= 1; i--) {
			int cost = elements[i * 2 + 1] + baseCost[i + 1];
			if (cost < baseCost[i]) {
				baseCost[i] = cost;
			}
		}
	}

	void computeMap() {
		// map all continuous integer subsequences to one index
		// let (int left, int right) = first appearance of CIS
		// return numE*leftInd + right;

		map = new int[numP][numP];
		for (int i = 0; i < numP; i++) {
			for (int j = 0; j < numP; j++) {
				map[i][j] = numP * i + j;
			}
		}

		for (int eLeft = 0; eLeft < numP; eLeft++) {
			for (int lLeft = eLeft + 1; lLeft < numP; lLeft++) {
				for (int cInd = 0; cInd < numP; cInd++) {
					if (cInd == 0) {
						if (elements[wrapE(2 * lLeft)] == elements[wrapE(2 * eLeft)]) {
							map[lLeft][lLeft] = map[eLeft][eLeft];
						}
					} else {
						int lRight = wrapP(lLeft + cInd);
						int eRight = wrapP(eLeft + cInd);
						if (map[lLeft][wrapP(lRight - 1)] == map[eLeft][wrapP(eRight - 1)]
								&& elements[wrapE(2 * lRight - 1)] == elements[wrapE(2 * eRight - 1)]
								&& elements[wrapE(2 * lRight)] == elements[wrapE(2 * eRight)]) {
							map[lLeft][lRight] = map[eLeft][eRight];
						}
					}
				}
			}
		}
	}

	// extend by 2
	@SuppressWarnings("unchecked")
	void computeExtensions() {
		lExtension = new ArrayList[numP * numP];
		rExtension = new ArrayList[numP * numP];
		for (int i = 0; i < numP * numP; i++) {
			lExtension[i] = new ArrayList<Integer>();
			rExtension[i] = new ArrayList<Integer>();
		}

		for (int lInd = 0; lInd < numP; lInd++) {
			for (int rInd = 0; rInd < numP; rInd++) {
				if (lInd - rInd == 1) {
					// cannot be whole array
					continue;
				}
				int lExt = wrapP(lInd - 1);
				int rExt = wrapP(rInd + 1);

				if (map[lExt][rInd] == numP * lExt + rInd) {
					lExtension[map[lInd][rInd]].add(map[lExt][rInd]);
				}
				if (map[lInd][rExt] == numP * lInd + rExt) {
					rExtension[map[lInd][rInd]].add(map[lInd][rExt]);
				}
			}
		}
	}
}
